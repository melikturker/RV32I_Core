#!/usr/bin/env python3
"""
RV32I ISA Full Coverage Test Generator

Generates a comprehensive assembly test that exercises every RV32I instruction
with deterministic inputs and verifiable outputs using signature-based checking.

Usage:
    python3 isa_full_coverage_gen.py [--output isa_coverage.s]
"""

import argparse
import sys

class ISACoverageGenerator:
    def __init__(self):
        self.code_lines = []
        self.memory_offset = 0
        self.expected_signature = {}
        self.covered_instructions = set()
        
        # RV32I Base Instruction Set (excluding system/CSR)
        self.rv32i_instructions = {
            'alu_r': ['ADD', 'SUB', 'SLL', 'SLT', 'SLTU', 'XOR', 'SRL', 'SRA', 'OR', 'AND'],
            'alu_i': ['ADDI', 'SLTI', 'SLTIU', 'XORI', 'ORI', 'ANDI', 'SLLI', 'SRLI', 'SRAI'],
            'load': ['LB', 'LH', 'LW', 'LBU', 'LHU'],
            'store': ['SB', 'SH', 'SW'],
            'branch': ['BEQ', 'BNE', 'BLT', 'BGE', 'BLTU', 'BGEU'],
            'jump': ['JAL', 'JALR'],
            'upper': ['LUI', 'AUIPC'],
            'system': ['EBREAK']  # ECALL skipped for bare-metal
        }
    
    def add_comment(self, text, level=0):
        indent = "    " * level
        self.code_lines.append(f"{indent}// {text}")
    
    def add_instruction(self, inst):
        self.code_lines.append(f"    {inst}")
    
    def mark_covered(self, inst):
        self.covered_instructions.add(inst.upper())
    
    def store_result(self, reg, expected_value, comment=""):
        """Store register to memory and track expected signature"""
        self.add_instruction(f"sw {reg}, {self.memory_offset}(x0)  // Expect: {expected_value} {comment}")
        self.expected_signature[self.memory_offset] = expected_value & 0xFFFFFFFF
        self.memory_offset += 4
    
    def generate_header(self):
        self.code_lines.append("// Auto-generated RV32I Full Coverage Test")
        self.code_lines.append("// DO NOT EDIT - Generated by isa_full_coverage_gen.py")
        self.code_lines.append("")
        self.code_lines.append(".text")
        self.code_lines.append(".globl _start")
        self.code_lines.append("")
        self.code_lines.append("_start:")
        self.add_comment("Initialize test registers with known values")
        self.add_instruction("addi x1, x0, 1")
        self.add_instruction("addi x2, x0, 2")
        self.add_instruction("addi x3, x0, 3")
        self.add_instruction("addi x4, x0, 4")
        self.add_instruction("addi x5, x0, 8")
        self.code_lines.append("")
    
    def generate_r_type_tests(self):
        self.add_comment("=== R-Type ALU Instructions ===")
        self.code_lines.append("")
        
        tests = [
            ("add",  "x10, x1, x2",  1 + 2, "ADD"),
            ("sub",  "x11, x3, x1",  3 - 1, "SUB"),
            ("and",  "x12, x2, x3",  2 & 3, "AND"),
            ("or",   "x13, x1, x2",  1 | 2, "OR"),
            ("xor",  "x14, x2, x3",  2 ^ 3, "XOR"),
            ("sll",  "x15, x2, x1",  2 << 1, "SLL"),
            ("srl",  "x16, x5, x1",  8 >> 1, "SRL"),
            ("sra",  "x17, x5, x1",  8 >> 1, "SRA"),  # Same for positive nums
            ("slt",  "x18, x1, x2",  1, "SLT"),  # 1 < 2 = true
            ("sltu", "x19, x1, x2",  1, "SLTU"),
        ]
        
        for inst, operands, expected, name in tests:
            self.add_instruction(f"{inst} {operands}")
            reg = operands.split(',')[0].strip()
            self.store_result(reg, expected, f"({name})")
            self.mark_covered(name)
        
        self.code_lines.append("")
    
    def generate_i_type_tests(self):
        self.add_comment("=== I-Type ALU Instructions ===")
        self.code_lines.append("")
        
        tests = [
            ("addi",  "x20, x1, 10",  1 + 10, "ADDI"),
            ("slti",  "x21, x1, 2",   1, "SLTI"),  # 1 < 2 = true
            ("sltiu", "x22, x1, 2",   1, "SLTIU"),
            ("xori",  "x23, x2, 3",   2 ^ 3, "XORI"),
            ("ori",   "x24, x1, 2",   1 | 2, "ORI"),
            ("andi",  "x25, x3, 2",   3 & 2, "ANDI"),
            ("slli",  "x26, x2, 2",   2 << 2, "SLLI"),
            ("srli",  "x27, x5, 1",   8 >> 1, "SRLI"),
            ("srai",  "x28, x5, 1",   8 >> 1, "SRAI"),
        ]
        
        for inst, operands, expected, name in tests:
            self.add_instruction(f"{inst} {operands}")
            reg = operands.split(',')[0].strip()
            self.store_result(reg, expected, f"({name})")
            self.mark_covered(name)
        
        self.code_lines.append("")
    
    def generate_upper_imm_tests(self):
        self.add_comment("=== Upper Immediate Instructions ===")
        self.code_lines.append("")
        
        # LUI
        self.add_instruction("lui x6, 0x12345")
        self.mark_covered("LUI")
        self.store_result("x6", 0x12345000, "(LUI)")
        
        # AUIPC - add to current PC
        # Can't predict exact value, just verify it executes
        self.add_instruction("auipc x7, 0")
        self.mark_covered("AUIPC")
        self.store_result("x7", 0xFFFFFFFF, "(AUIPC - unpredictable)")
        
        self.code_lines.append("")
    
    def generate_load_store_tests(self):
        self.add_comment("=== Load/Store Instructions ===")
        self.code_lines.append("")
        
        # Prepare test data
        self.add_instruction("addi x8, x0, 0xAB")
        self.add_instruction("addi x9, x0, 200")  # Test address
        
        # SW (word)
        self.add_instruction("sw x8, 0(x9)")
        self.mark_covered("SW")
        
        # LW (word)
        self.add_instruction("lw x10, 0(x9)")
        self.mark_covered("LW")
        self.store_result("x10", 0xAB, "(LW)")
        
        # SH (halfword)
        self.add_instruction("addi x11, x0, 0xCD")
        self.add_instruction("sh x11, 4(x9)")
        self.mark_covered("SH")
        
        # LH (halfword signed)
        self.add_instruction("lh x12, 4(x9)")
        self.mark_covered("LH")
        self.store_result("x12", 0xCD, "(LH)")
        
        # LHU (halfword unsigned)
        self.add_instruction("lhu x13, 4(x9)")
        self.mark_covered("LHU")
        self.store_result("x13", 0xCD, "(LHU)")
        
        # SB (byte)
        self.add_instruction("addi x14, x0, 0x42")
        self.add_instruction("sb x14, 8(x9)")
        self.mark_covered("SB")
        
        # LB (byte signed)
        self.add_instruction("lb x15, 8(x9)")
        self.mark_covered("LB")
        self.store_result("x15", 0x42, "(LB)")
        
        # LBU (byte unsigned)
        self.add_instruction("lbu x16, 8(x9)")
        self.mark_covered("LBU")
        self.store_result("x16", 0x42, "(LBU)")
        
        self.code_lines.append("")
    
    def generate_branch_tests(self):
        self.add_comment("=== Branch Instructions ===")
        self.code_lines.append("")
        
        # BEQ
        self.add_instruction("beq x1, x1, beq_taken")
        self.add_instruction("addi x17, x0, 999  // Should skip")
        self.add_instruction("j test_fail")
        self.code_lines.append("beq_taken:")
        self.add_instruction("addi x17, x0, 1")
        self.mark_covered("BEQ")
        self.store_result("x17", 1, "(BEQ)")
        
        # BNE
        self.add_instruction("bne x1, x2, bne_taken")
        self.add_instruction("j test_fail")
        self.code_lines.append("bne_taken:")
        self.add_instruction("addi x18, x0, 2")
        self.mark_covered("BNE")
        self.store_result("x18", 2, "(BNE)")
        
        # BLT
        self.add_instruction("blt x1, x2, blt_taken")
        self.add_instruction("j test_fail")
        self.code_lines.append("blt_taken:")
        self.add_instruction("addi x19, x0, 3")
        self.mark_covered("BLT")
        self.store_result("x19", 3, "(BLT)")
        
        # BGE
        self.add_instruction("bge x2, x1, bge_taken")
        self.add_instruction("j test_fail")
        self.code_lines.append("bge_taken:")
        self.add_instruction("addi x20, x0, 4")
        self.mark_covered("BGE")
        self.store_result("x20", 4, "(BGE)")
        
        # BLTU
        self.add_instruction("bltu x1, x2, bltu_taken")
        self.add_instruction("j test_fail")
        self.code_lines.append("bltu_taken:")
        self.add_instruction("addi x21, x0, 5")
        self.mark_covered("BLTU")
        self.store_result("x21", 5, "(BLTU)")
        
        # BGEU
        self.add_instruction("bgeu x2, x1, bgeu_taken")
        self.add_instruction("j test_fail")
        self.code_lines.append("bgeu_taken:")
        self.add_instruction("addi x22, x0, 6")
        self.mark_covered("BGEU")
        self.store_result("x22", 6, "(BGEU)")
        
        self.code_lines.append("")
    
    def generate_jump_tests(self):
        self.add_comment("=== Jump Instructions ===")
        self.code_lines.append("")
        
        # JAL
        self.add_instruction("jal x23, jal_target")
        self.add_instruction("j test_fail")
        self.code_lines.append("jal_target:")
        self.mark_covered("JAL")
        self.store_result("x23", 0xFFFFFFFF, "(JAL return addr - unpredictable)")
        
        # JALR
        self.add_instruction("lui x24, %hi(jalr_target)")
        self.add_instruction("addi x24, x24, %lo(jalr_target)")
        self.add_instruction("jalr x25, 0(x24)")
        self.add_instruction("j test_fail")
        self.code_lines.append("jalr_target:")
        self.mark_covered("JALR")
        self.store_result("x25", 0xFFFFFFFF, "(JALR return addr - unpredictable)")
        
        self.code_lines.append("")
    
    def generate_verification(self):
        self.add_comment("=== Signature Verification ===")
        self.code_lines.append("")
        
        # Compute checksum of predictable values only
        self.add_instruction("addi x31, x0, 0  // Accumulator")
        
        predictable_offsets = [o for o, v in self.expected_signature.items() if v != 0xFFFFFFFF]
        
        for offset in sorted(predictable_offsets):
            self.add_instruction(f"lw x30, {offset}(x0)")
            self.add_instruction("add x31, x31, x30")
        
        expected_sum = sum(v for v in self.expected_signature.values() if v != 0xFFFFFFFF) & 0xFFFFFFFF
        
        self.code_lines.append("")
        self.add_comment(f"Expected checksum: 0x{expected_sum:08x}")
        
        # Load expected value
        if expected_sum < 2048:
            self.add_instruction(f"addi x29, x0, {expected_sum}")
        else:
            upper = (expected_sum >> 12) & 0xFFFFF
            lower = expected_sum & 0xFFF
            self.add_instruction(f"lui x29, {upper}")
            if lower > 0:
                self.add_instruction(f"addi x29, x29, {lower}")
        
        self.add_instruction("beq x31, x29, test_pass")
        self.code_lines.append("")
        
        self.code_lines.append("test_fail:")
        self.add_instruction("ebreak")
        self.code_lines.append("")
        
        self.code_lines.append("test_pass:")
        self.add_instruction("addi x1, x0, 0xC0DE  // Success marker")
        self.mark_covered("EBREAK")
        self.add_instruction("ebreak")
    
    def generate_coverage_report(self):
        """Generate coverage report as comments at the end"""
        self.code_lines.append("")
        self.code_lines.append("// ===== COVERAGE REPORT =====")
        
        all_instructions = []
        for cat, insts in self.rv32i_instructions.items():
            all_instructions.extend(insts)
        
        covered = len(self.covered_instructions)
        total = len(all_instructions)
        percentage = (covered / total) * 100 if total > 0 else 0
        
        self.code_lines.append(f"// Coverage: {covered}/{total} instructions ({percentage:.1f}%)")
        self.code_lines.append("//")
        
        for category, instructions in self.rv32i_instructions.items():
            self.code_lines.append(f"// {category.upper()}:")
            for inst in instructions:
                status = "‚úì" if inst in self.covered_instructions else "‚úó"
                self.code_lines.append(f"//   {status} {inst}")
        
        self.code_lines.append("// ===========================")
    
    def generate(self):
        """Generate complete test"""
        self.generate_header()
        self.generate_r_type_tests()
        self.generate_i_type_tests()
        self.generate_upper_imm_tests()
        self.generate_load_store_tests()
        self.generate_branch_tests()
        self.generate_jump_tests()
        self.generate_verification()
        self.generate_coverage_report()
        
        return "\n".join(self.code_lines)
    
    def get_coverage_stats(self):
        all_instructions = []
        for insts in self.rv32i_instructions.values():
            all_instructions.extend(insts)
        
        return {
            'covered': len(self.covered_instructions),
            'total': len(all_instructions),
            'percentage': (len(self.covered_instructions) / len(all_instructions)) * 100,
            'missing': set(all_instructions) - self.covered_instructions
        }

def main():
    parser = argparse.ArgumentParser(description="Generate RV32I Full Coverage Test")
    parser.add_argument("--output", "-o", default="isa_full_coverage.s",
                       help="Output assembly file (default: isa_full_coverage.s)")
    parser.add_argument("--verbose", "-v", action="store_true",
                       help="Print coverage report")
    args = parser.parse_args()
    
    gen = ISACoverageGenerator()
    asm_code = gen.generate()
    
    # Write to file
    with open(args.output, 'w') as f:
        f.write(asm_code)
    
    # Print stats
    stats = gen.get_coverage_stats()
    print(f"‚úÖ Generated: {args.output}")
    print(f"üìä Coverage: {stats['covered']}/{stats['total']} instructions ({stats['percentage']:.1f}%)")
    
    if stats['missing']:
        print(f"‚ö†Ô∏è  Missing: {', '.join(sorted(stats['missing']))}")
    
    if args.verbose:
        print("\nCovered instructions:")
        for inst in sorted(gen.covered_instructions):
            print(f"  ‚úì {inst}")

if __name__ == "__main__":
    main()
